{"ast":null,"code":"//@ts-nocheck\nconst rotorProcess = (inputRow, outputRow, index) => outputRow.indexOf(inputRow[index]);\n/*\nTakes a number and a string and return the index of the other occurance of the character at that point\ne.g aabbcc and 0 would return 1\nI'm aware this isn't the fastest way to do it, but it keeps it concise and also has good automatic handling of \nan index larger than the length of the string, if speed became an issue I would change this\n*/\n\n\nconst reflector = (reflector, index) => {\n  const charAtIndex = reflector[index];\n  const firstIndex = reflector.indexOf(charAtIndex);\n\n  if (firstIndex == index) {\n    return reflector.lastIndexOf(charAtIndex);\n  } else {\n    return firstIndex;\n  }\n};\n/*\nTakes an index and a string of length 26(must be permutation of alphabet for our purposes)\nReturns string shifted by that index\n*/\n\n\nconst rotate = (string, index) => string.length == 26 && string.substring(index % 26) + string.substring(0, index % 26);\n\nexport const encryptString = (input, rotors, reflector) => {\n  const initialState = {\n    charAlphabetPos: input.charCodeAt(0) - 97,\n    rotorHighlights: []\n  };\n  let forwardPass = rotors.reduce(initialState, (state, rotor) => {\n    const rotorResult = rotorProcess(state.charAlphabetPos, rotate(rotor.inputRow, rotor.shift), rotor.outputRow);\n    return {\n      charAlphabetPos: rotorResult,\n      rotorHighlights: [...state.rotorHighlights, rotorResult]\n    };\n  }); //Pass through reflector\n\n  const reflectedResult = reflector(reflector, forwardPass.charAlphabetPos);\n  let reflectedPass = { ...forwardPass,\n    charAlphabetPos: reflectedResult,\n    rotorHighlights: [...forwardPass.rotorHighlights, reflectedResult]\n  }; //This is very similar to the forward pass, I'm aware its a violation of DRY- but it would probably make the code substantially less readable were I to generalise this.\n\n  let backwardPass = rotors.reduce(initialState, (state, rotor) => {\n    const rotorResult = rotorProcess(state.charAlphabetPos, rotor.outputRow, rotate(rotor.inputRow, rotor.shift));\n    return {\n      charAlphabetPos: rotorResult,\n      rotorHighlights: [...state.rotorHighlights, rotorResult]\n    };\n  });\n  return backwardPass;\n};","map":{"version":3,"sources":["/home/dannyp/Documents/Projects/Professional/enigma/src/machineLogic.tsx"],"names":["rotorProcess","inputRow","outputRow","index","indexOf","reflector","charAtIndex","firstIndex","lastIndexOf","rotate","string","length","substring","encryptString","input","rotors","initialState","charAlphabetPos","charCodeAt","rotorHighlights","forwardPass","reduce","state","rotor","rotorResult","shift","reflectedResult","reflectedPass","backwardPass"],"mappings":"AAAA;AACA,MAAMA,YAAY,GAAG,CAACC,QAAD,EAAgBC,SAAhB,EAAgCC,KAAhC,KACnBD,SAAS,CAACE,OAAV,CAAkBH,QAAQ,CAACE,KAAD,CAA1B,CADF;AAEA;;;;;;;;AAMA,MAAME,SAAS,GAAG,CAACA,SAAD,EAAoBF,KAApB,KAAsC;AACtD,QAAMG,WAAW,GAAGD,SAAS,CAACF,KAAD,CAA7B;AACA,QAAMI,UAAU,GAAGF,SAAS,CAACD,OAAV,CAAkBE,WAAlB,CAAnB;;AACA,MAAIC,UAAU,IAAIJ,KAAlB,EAAyB;AACvB,WAAOE,SAAS,CAACG,WAAV,CAAsBF,WAAtB,CAAP;AACD,GAFD,MAEO;AACL,WAAOC,UAAP;AACD;AACF,CARD;AAUA;;;;;;AAIA,MAAME,MAAM,GAAG,CAACC,MAAD,EAAiBP,KAAjB,KACbO,MAAM,CAACC,MAAP,IAAiB,EAAjB,IACAD,MAAM,CAACE,SAAP,CAAiBT,KAAK,GAAG,EAAzB,IAA+BO,MAAM,CAACE,SAAP,CAAiB,CAAjB,EAAoBT,KAAK,GAAG,EAA5B,CAFjC;;AAIA,OAAO,MAAMU,aAAa,GAAG,CAACC,KAAD,EAAgBC,MAAhB,EAA6BV,SAA7B,KAAgD;AAC3E,QAAMW,YAAY,GAAG;AACnBC,IAAAA,eAAe,EAAEH,KAAK,CAACI,UAAN,CAAiB,CAAjB,IAAsB,EADpB;AAEnBC,IAAAA,eAAe,EAAE;AAFE,GAArB;AAIA,MAAIC,WAAW,GAAGL,MAAM,CAACM,MAAP,CAAcL,YAAd,EAA4B,CAACM,KAAD,EAAaC,KAAb,KAA4B;AACxE,UAAMC,WAAW,GAAGxB,YAAY,CAC9BsB,KAAK,CAACL,eADwB,EAE9BR,MAAM,CAACc,KAAK,CAACtB,QAAP,EAAiBsB,KAAK,CAACE,KAAvB,CAFwB,EAG9BF,KAAK,CAACrB,SAHwB,CAAhC;AAKA,WAAO;AACLe,MAAAA,eAAe,EAAEO,WADZ;AAELL,MAAAA,eAAe,EAAE,CAAC,GAAGG,KAAK,CAACH,eAAV,EAA2BK,WAA3B;AAFZ,KAAP;AAID,GAViB,CAAlB,CAL2E,CAgB3E;;AACA,QAAME,eAAe,GAAGrB,SAAS,CAACA,SAAD,EAAYe,WAAW,CAACH,eAAxB,CAAjC;AACA,MAAIU,aAAa,GAAG,EAClB,GAAGP,WADe;AAElBH,IAAAA,eAAe,EAAES,eAFC;AAGlBP,IAAAA,eAAe,EAAE,CAAC,GAAGC,WAAW,CAACD,eAAhB,EAAiCO,eAAjC;AAHC,GAApB,CAlB2E,CAuB3E;;AACA,MAAIE,YAAY,GAAGb,MAAM,CAACM,MAAP,CAAcL,YAAd,EAA4B,CAACM,KAAD,EAAaC,KAAb,KAA4B;AACzE,UAAMC,WAAW,GAAGxB,YAAY,CAC9BsB,KAAK,CAACL,eADwB,EAE9BM,KAAK,CAACrB,SAFwB,EAG9BO,MAAM,CAACc,KAAK,CAACtB,QAAP,EAAiBsB,KAAK,CAACE,KAAvB,CAHwB,CAAhC;AAKA,WAAO;AACLR,MAAAA,eAAe,EAAEO,WADZ;AAELL,MAAAA,eAAe,EAAE,CAAC,GAAGG,KAAK,CAACH,eAAV,EAA2BK,WAA3B;AAFZ,KAAP;AAID,GAVkB,CAAnB;AAWA,SAAOI,YAAP;AACD,CApCM","sourcesContent":["//@ts-nocheck\nconst rotorProcess = (inputRow: any, outputRow: any, index: number) =>\n  outputRow.indexOf(inputRow[index]);\n/*\nTakes a number and a string and return the index of the other occurance of the character at that point\ne.g aabbcc and 0 would return 1\nI'm aware this isn't the fastest way to do it, but it keeps it concise and also has good automatic handling of \nan index larger than the length of the string, if speed became an issue I would change this\n*/\nconst reflector = (reflector: string, index: number) => {\n  const charAtIndex = reflector[index];\n  const firstIndex = reflector.indexOf(charAtIndex);\n  if (firstIndex == index) {\n    return reflector.lastIndexOf(charAtIndex);\n  } else {\n    return firstIndex;\n  }\n};\n\n/*\nTakes an index and a string of length 26(must be permutation of alphabet for our purposes)\nReturns string shifted by that index\n*/\nconst rotate = (string: string, index: number) =>\n  string.length == 26 &&\n  string.substring(index % 26) + string.substring(0, index % 26);\n\nexport const encryptString = (input: string, rotors: any, reflector: any) => {\n  const initialState = {\n    charAlphabetPos: input.charCodeAt(0) - 97,\n    rotorHighlights: [],\n  };\n  let forwardPass = rotors.reduce(initialState, (state: any, rotor: any) => {\n    const rotorResult = rotorProcess(\n      state.charAlphabetPos,\n      rotate(rotor.inputRow, rotor.shift),\n      rotor.outputRow\n    );\n    return {\n      charAlphabetPos: rotorResult,\n      rotorHighlights: [...state.rotorHighlights, rotorResult],\n    };\n  });\n  //Pass through reflector\n  const reflectedResult = reflector(reflector, forwardPass.charAlphabetPos);\n  let reflectedPass = {\n    ...forwardPass,\n    charAlphabetPos: reflectedResult,\n    rotorHighlights: [...forwardPass.rotorHighlights, reflectedResult],\n  };\n  //This is very similar to the forward pass, I'm aware its a violation of DRY- but it would probably make the code substantially less readable were I to generalise this.\n  let backwardPass = rotors.reduce(initialState, (state: any, rotor: any) => {\n    const rotorResult = rotorProcess(\n      state.charAlphabetPos,\n      rotor.outputRow,\n      rotate(rotor.inputRow, rotor.shift)\n    );\n    return {\n      charAlphabetPos: rotorResult,\n      rotorHighlights: [...state.rotorHighlights, rotorResult],\n    };\n  });\n  return backwardPass;\n};\n"]},"metadata":{},"sourceType":"module"}