{"ast":null,"code":"var _jsxFileName = \"/home/dannyp/Documents/Projects/Professional/enigma/src/App.tsx\";\nimport React, { useReducer, useState } from \"react\";\nimport \"./App.css\";\nimport { encryptString } from \"./machineLogic\";\nimport { rotors } from \"./config\";\nconsole.log(encryptString);\n\nfunction App() {\n  const reducer = (state, action) => {\n    const rotate = (string, index) => string.length == 26 && string.substring(index % 26) + string.substring(0, index % 26);\n\n    switch (action.type) {\n      case \"rotateRotor\":\n        return { ...state,\n          rotors: state.rotors.map( //Iterate through rotors, return original value if not on value to be changed, else return specified value\n          (oldValue, index) => index == action.payload.rotorIndex ? rotate(oldValue, action.payload.shift) : oldValue)\n        };\n    }\n  };\n\n  const initialState = {\n    rotorShift: 0,\n    rotors: rotors\n  };\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const [shifted, setShifted] = useState(false);\n  console.log(state);\n\n  if (!shifted) {\n    setShifted(true);\n    dispatch({\n      type: \"rotateRotor\",\n      payload: {\n        rotorIndex: 1,\n        shift: 1\n      }\n    });\n  }\n  /*\n    Takes two strings(both permuations of the alphabet), and an index. \n    Finds the character at the given index in inputRow, then\n    returns the index of that character in the outputRow.   \n    Returns -1 when given invalid input\n  */\n\n\n  const rotorProcess = (inputRow, outputRow, index) => outputRow.indexOf(inputRow[index]);\n  /*\n    Takes a number and a string and return the index of the other occurance of the character at that point\n    e.g aabbcc and 0 would return 1\n    I'm aware this isn't the fastest way to do it, but it keeps it concise and also has good automatic handling of \n    an index larger than the length of the string, if speed became an issue I would change this\n  */\n\n\n  const reflector = (reflector, index) => {\n    const charAtIndex = reflector[index];\n    const firstIndex = reflector.indexOf(charAtIndex);\n\n    if (firstIndex == index) {\n      return reflector.lastIndexOf(charAtIndex);\n    } else {\n      return firstIndex;\n    }\n  };\n  /*\n  Takes an index and a string of length 26(must be permutation of alphabet for our purposes)\n  Returns string shifted by that index\n  */\n\n\n  const rotate = (string, index) => string.length == 26 && string.substring(index % 26) + string.substring(0, index % 26);\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"App\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 73,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"header\", {\n    className: \"App-header\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 74,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"h1\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 75,\n      columnNumber: 9\n    }\n  }, \"Engima\"), /*#__PURE__*/React.createElement(\"h2\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 76,\n      columnNumber: 9\n    }\n  }, \"Rotor Shift: \", state.rotorShift), /*#__PURE__*/React.createElement(\"h2\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 77,\n      columnNumber: 9\n    }\n  }, \"Rotor Settings: \", state.rotorSettings)));\n}\n\nexport default App;","map":{"version":3,"sources":["/home/dannyp/Documents/Projects/Professional/enigma/src/App.tsx"],"names":["React","useReducer","useState","encryptString","rotors","console","log","App","reducer","state","action","rotate","string","index","length","substring","type","map","oldValue","payload","rotorIndex","shift","initialState","rotorShift","dispatch","shifted","setShifted","rotorProcess","inputRow","outputRow","indexOf","reflector","charAtIndex","firstIndex","lastIndexOf","rotorSettings"],"mappings":"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","sourcesContent":["import React, { useReducer, useState } from \"react\";\nimport \"./App.css\";\nimport { encryptString } from \"./machineLogic\";\nimport { rotors } from \"./config\";\nconsole.log(encryptString);\nfunction App() {\n  const reducer = (state: any, action: any) => {\n    const rotate = (string: string, index: number) =>\n      string.length == 26 &&\n      string.substring(index % 26) + string.substring(0, index % 26);\n\n    switch (action.type) {\n      case \"rotateRotor\":\n        return {\n          ...state,\n          rotors: state.rotors.map(\n            //Iterate through rotors, return original value if not on value to be changed, else return specified value\n            (oldValue: string, index: number) =>\n              index == action.payload.rotorIndex\n                ? rotate(oldValue, action.payload.shift)\n                : oldValue\n          ),\n        };\n    }\n  };\n\n  const initialState = {\n    rotorShift: 0,\n    rotors: rotors,\n  };\n\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const [shifted, setShifted] = useState(false);\n  console.log(state);\n  if (!shifted) {\n    setShifted(true);\n    dispatch({ type: \"rotateRotor\", payload: { rotorIndex: 1, shift: 1 } });\n  }\n\n  /*\n    Takes two strings(both permuations of the alphabet), and an index. \n    Finds the character at the given index in inputRow, then\n    returns the index of that character in the outputRow.   \n    Returns -1 when given invalid input\n  */\n  const rotorProcess = (inputRow: string, outputRow: string, index: number) =>\n    outputRow.indexOf(inputRow[index]);\n  /*\n    Takes a number and a string and return the index of the other occurance of the character at that point\n    e.g aabbcc and 0 would return 1\n    I'm aware this isn't the fastest way to do it, but it keeps it concise and also has good automatic handling of \n    an index larger than the length of the string, if speed became an issue I would change this\n  */\n  const reflector = (reflector: string, index: number) => {\n    const charAtIndex = reflector[index];\n    const firstIndex = reflector.indexOf(charAtIndex);\n    if (firstIndex == index) {\n      return reflector.lastIndexOf(charAtIndex);\n    } else {\n      return firstIndex;\n    }\n  };\n\n  /*\n  Takes an index and a string of length 26(must be permutation of alphabet for our purposes)\n  Returns string shifted by that index\n  */\n  const rotate = (string: string, index: number) =>\n    string.length == 26 &&\n    string.substring(index % 26) + string.substring(0, index % 26);\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h1>Engima</h1>\n        <h2>Rotor Shift: {state.rotorShift}</h2>\n        <h2>Rotor Settings: {state.rotorSettings}</h2>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}